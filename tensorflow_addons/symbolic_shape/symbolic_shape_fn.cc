// Copyright 2023 The RECom Authors. All rights reserved.
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#include "symbolic_shape_fn.h"
#include <functional>
#include <string>
#include <symengine/expression.h>
#include <symengine/printers.h>
#include <tensorflow/core/framework/node_def.pb.h>
#include <tensorflow/core/framework/types.h>
#include <vector>

namespace tensorflow {
namespace feature_opt {

std::string ExprVecToStr(const ExprVec &expr_vec) {
  std::string s = "[ ";
  for (const Expression &expr : expr_vec) {
    s += SymEngine::str(expr) + " ";
  }
  s += "]";
  return s;
}

std::string IntVecToStr(const std::vector<int> &vec) {
  std::string s = "[ ";
  for (int i : vec) {
    s += std::to_string(i) + " ";
  }
  s += "]";
  return s;
}

Expression SymbolicShapeContext::AddNewSymbol(NodeDef *node) {
  auto symbol = Symbol(symbols.size(), node);
  symbols.push_back(symbol);
  RECOM_VLOG << "Symbol " << symbol.expr << " is generated by node "
             << node->name();
  return symbol.expr;
}

bool SymbolicShapeContext::IsStatic(const ExprVec &exprs) {
  for (const Expression &expr : exprs) {
    RETURN_IF_FALSE(is_a_Number(expr));
  }
  return true;
}

bool SymbolicShapeContext::IsSymbol(const Expression &expr) {
  std::string s = SymEngine::str(expr);
  RETURN_IF_FALSE(s.size() >= 2 && s[0] == 'x');
  for (int i = 1; i < s.size(); ++i) {
    RETURN_IF_FALSE(s[i] >= '0' && s[i] <= '9');
  }
  return true;
}

int SymbolicShapeContext::FindParentIdx(int idx) {
  if (symbols[idx].parent_idx == -1)
    return idx;
  return symbols[idx].parent_idx = FindParentIdx(symbols[idx].parent_idx);
}

bool SymbolicShapeContext::UnionSymbols(int a, int b) {
  int ap = FindParentIdx(a);
  int bp = FindParentIdx(b);
  if (ap == bp)
    return false;

  if (!IsNumeric(ap) && !IsNumeric(bp)) {
    if (ap > bp)
      std::swap(ap, bp);
    symbols[bp].parent_idx = ap;
    RECOM_VLOG << "Union " << symbols[ap].expr << " and " << symbols[bp].expr;
  } else if (IsNumeric(ap) && IsNumeric(bp)) {
    LOG_AND_RETURN_IF_FALSE(symbols[ap].expr == symbols[bp].expr,
                            "Union two symbols with different numeric value!");
  } else if (IsNumeric(ap)) {
    RETURN_IF_FALSE(SetSymbol(bp, static_cast<int>(symbols[ap].expr)));
  } else if (IsNumeric(bp)) {
    RETURN_IF_FALSE(SetSymbol(ap, static_cast<int>(symbols[bp].expr)));
  }

  return true;
}

bool SymbolicShapeContext::SetSymbol(int idx, int value) {
  RETURN_IF_FALSE(IsNumeric(idx));

  Expression orig_expr = symbols[idx].expr;
  symbols[idx].expr = Expression(value);
  RECOM_VLOG << "Set symbol " << orig_expr << " to " << value;

  SubsAll(orig_expr, Expression(value));

  return true;
}

std::set<int>
SymbolicShapeContext::RetrieveSymbolIdxSet(const Expression &expr) {
  std::string str = SymEngine::str(expr);
  std::set<int> results;
  for (int i = 0; i < str.size(); ++i) {
    if (str[i] == 'x') {
      int idx = 0;
      ++i;
      while (i < str.size() && str[i] >= '0' && str[i] <= '9') {
        idx = idx * 10 + (str[i] - '0');
        ++i;
      }
      results.insert(idx);
    }
  }

  return results;
}

Expression SymbolicShapeContext::SubsWithParent(Expression expr) {
  std::set<int> symbol_idx_set = RetrieveSymbolIdxSet(expr);
  for (int idx : symbol_idx_set) {
    int parent_idx = FindParentIdx(idx);
    if (idx != parent_idx) {
      expr = expr.subs({{symbols[idx].expr, symbols[parent_idx].expr}});
    }
  }
  return expr;
}

void SymbolicShapeContext::SubsAll(const Expression &a, const Expression &b) {
  for (auto &pair : symbolic_shape_mapping) {
    for (Expression &expr : pair.second) {
      expr = expr.subs({{a, b}});
    }
  }
  for (auto &pair : symbolic_content_mapping) {
    for (Expression &expr : pair.second) {
      expr = expr.subs({{a, b}});
    }
  }
}

bool SymbolicShapeContext::IsEq(const Expression &a, const Expression &b) {
  return SubsWithParent(a) == SubsWithParent(b);
}

bool SymbolicShapeContext::IsEq(const ExprVec &a, const ExprVec &b) {
  RETURN_IF_FALSE(a.size() == b.size());
  for (int i = 0; i < a.size(); ++i) {
    RETURN_IF_FALSE(IsEq(a[i], b[i]));
  }
  return true;
}

bool SymbolicShapeContext::MakeEq(const Expression &a, const Expression &b) {
  const Expression ap = SubsWithParent(a);
  const Expression bp = SubsWithParent(b);
  if (ap == bp)
    return true;

  std::set<int> a_symbol_idx_set = RetrieveSymbolIdxSet(ap);
  std::set<int> b_symbol_idx_set = RetrieveSymbolIdxSet(bp);

  auto minus = [](const std::set<int> &lhs, const std::set<int> &rhs) {
    std::set<int> diff;
    for (int v : lhs) {
      if (!rhs.count(v))
        diff.insert(v);
    }
    return diff;
  };

  std::set<int> a_minus_b = minus(a_symbol_idx_set, b_symbol_idx_set);
  std::set<int> b_minus_a = minus(b_symbol_idx_set, a_symbol_idx_set);

  if (a_minus_b.size() == 1 && b_minus_a.size() == 1) {
    RETURN_IF_FALSE(UnionSymbols(*a_minus_b.begin(), *b_minus_a.begin()));
  } else if (a_minus_b.size() + b_minus_a.size() == 1) {
    int symbol_idx =
        a_minus_b.size() == 1 ? *a_minus_b.begin() : *b_minus_a.begin();
    Expression symbol_expr = symbols[symbol_idx].expr;
    Expression expect_zero = ap - bp;
    for (int n = MIN_ATTEMP; n < MAX_ATTEMP; ++n) {
      if (expect_zero.subs({{symbol_expr, Expression(n)}}) == Expression(0)) {
        RETURN_IF_FALSE(SetSymbol(symbol_idx, n));
      }
    }
  } else {
    LOG_AND_RETURN_FALSE(
        "Only support at most one different symbol when union expressions");
  }

  return true;
}

bool SymbolicShapeContext::ShapeKnown(const std::string &tensor_name) {
  return symbolic_shape_mapping.count(tensor_name);
}

bool SymbolicShapeContext::ShapeStatic(const std::string &tensor_name) {
  RETURN_IF_FALSE(symbolic_shape_mapping.count(tensor_name));
  return IsStatic(symbolic_shape_mapping.at(tensor_name));
}

bool SymbolicShapeContext::ShapeStatic(const std::string &tensor_name,
                                       std::vector<int> &shape) {
  RETURN_IF_FALSE(ShapeKnown(tensor_name));
  shape = std::vector<int>(symbolic_shape_mapping.at(tensor_name).size());
  auto itr = shape.begin();
  for (const Expression &expr : symbolic_shape_mapping.at(tensor_name)) {
    EXPR_TO_INT(*itr, expr);
    ++itr;
  }
  return true;
}

ExprVec SymbolicShapeContext::GetShape(const std::string &tensor_name) {
  return symbolic_shape_mapping.at(tensor_name);
}

void SymbolicShapeContext::SetShape(const std::string &tensor_name,
                                    const ExprVec &shape) {
  if (symbolic_shape_mapping.count(tensor_name)) {
    RECOM_VLOG_WARNING << "Symbolic shape is set multiple times";
  }
  symbolic_shape_mapping[tensor_name] = shape;
  RECOM_VLOG << "SetShape " << ExprVecToStr(shape) << " " << tensor_name;
}

bool SymbolicShapeContext::ContentKnown(const std::string &tensor_name) {
  return symbolic_content_mapping.count(tensor_name);
}

bool SymbolicShapeContext::InputContentKnown(NodeDef *node) {
  for (int i = 0; i < node->input_size(); ++i) {
    RETURN_IF_FALSE(ContentKnown(node->input(i)));
  }
  return true;
}

bool SymbolicShapeContext::ContentStatic(const std::string &tensor_name) {
  RETURN_IF_FALSE(ContentKnown(tensor_name));
  return IsStatic(symbolic_content_mapping.at(tensor_name));
}

bool SymbolicShapeContext::ContentStatic(const std::string &tensor_name,
                                         std::vector<int> &content) {
  RETURN_IF_FALSE(ContentKnown(tensor_name));
  content = std::vector<int>(symbolic_content_mapping.at(tensor_name).size());
  auto itr = content.begin();
  for (const Expression &expr : symbolic_content_mapping.at(tensor_name)) {
    EXPR_TO_INT(*itr, expr);
    ++itr;
  }
  return true;
}

ExprVec SymbolicShapeContext::GetContent(const std::string &tensor_name) {
  return symbolic_content_mapping.at(tensor_name);
}

void SymbolicShapeContext::SetContent(const std::string &tensor_name,
                                      const ExprVec &content) {
  if (symbolic_content_mapping.count(tensor_name)) {
    RECOM_VLOG_WARNING << "Symbolic content is set multiple times";
  }
  symbolic_content_mapping[tensor_name] = content;
  RECOM_VLOG << "SetContent " << ExprVecToStr(content) << " " << tensor_name;
}

bool SymbolicShapeContext::HasShapeNode(const std::string &tensor_name) {
  return tensor_shape_node_mapping.count(tensor_name);
}

NodeDef *SymbolicShapeContext::GetShapeNode(const std::string &tensor_name) {
  return tensor_shape_node_mapping.at(tensor_name);
}

void SymbolicShapeContext::RecordTensorShapeNode(const std::string &tensor_name,
                                                 NodeDef *node) {
  if (tensor_shape_node_mapping.count(tensor_name)) {
    RECOM_VLOG_WARNING << "Multiple shape nodes";
  }
  tensor_shape_node_mapping[tensor_name] = node;
  RECOM_VLOG << "RecordTensorShapeNode " << tensor_name << " - "
             << node->name();
}

std::vector<std::pair<Expression, NodeDef *>>
SymbolicShapeContext::RetrieveSymbolExprGenNodePairs(const Expression &expr) {
  std::set<int> symbol_idx_set = RetrieveSymbolIdxSet(expr);
  std::vector<std::pair<Expression, NodeDef *>> results;
  for (int symbol_idx : symbol_idx_set) {
    Symbol symbol = symbols[symbol_idx];
    results.push_back({symbol.expr, symbol.node});
  }
  return results;
}

std::vector<std::pair<Expression, NodeDef *>>
SymbolicShapeContext::FindEqSymbolExprGenNodePairs(
    const Expression &symbol_expr) {
  std::string str = SymEngine::str(symbol_expr);
  assert(str[0] == 'x');
  const int symbol_idx = std::stoi(str.substr(1));
  const int parent_idx = FindParentIdx(symbol_idx);

  std::vector<std::pair<Expression, NodeDef *>> results;
  for (const Symbol &symbol : symbols) {
    if (symbol.idx != symbol_idx && FindParentIdx(symbol.idx) == parent_idx) {
      results.push_back({symbol.expr, symbol.node});
    }
  }

  return results;
}

} // namespace feature_opt
} // namespace tensorflow